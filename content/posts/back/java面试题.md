---
title: "java面试题"
date: 2020-09-09
lastmod: 2021-09-09 12:12:12
draft: false
tags: ['javaSE']
categories: ["面试题"]
author: "lei"
---



# 面向对象

什么是面向对象？

对比面向过程，两种不同的处理问题的角度

面向过程注重处理事情的步骤顺序；面向对象注重事情的参与者（对象），以及各自需要做什么

面向过程比较直接，面向对象更易于代码的复用，扩展以及维护

**封装**

内部对外部提供调用调用的接口，外部不需要关心和修改内部实现

**继承**

继承基类方法，并做出自己的改变和扩展；子类共性的方法和属性不需要自己定义，只需要扩展自己个性化的

**多态**

存在条件：继承，重写，父类引用指向子类对象

# JDK JRE JVM

jdk：开发者工具包

jre：java运行环境

jvm：java虚拟机

jdk>jre>jvm

# ==和equals比较

==对比的是栈中的值，基本数据类型是变量值，引用类型是内存对象的地址

equals：object中默认采用==比较，通常需要重写

# final

最终的

- 修饰类：表示类不可被继承
- 修饰方法：表示方法不可被覆盖，但是可以重载
- 修饰变量：表示变量一旦赋值就不能更改它的值

1.修饰成员变量

- 如果final修饰的是类变量，只能在静态代码块或声明时给它赋值
- 如果final修饰的是成员变量，可以在实例代码块、声明时或构造器执行初始值

2.修饰局部变量

- 系统不会为局部变量进行初始化，局部变量可以在声明时初始化，也可以在后面代码中对final变量赋初始值（仅一次）

3.修饰基本数据类型和引用数据类型

- 基本数据类型的变量，一旦初始化后便不能更改
- 引用数据类型的变量，初始化后不能再让其指向另一个对象，可以修改引用对象的属性

**为什么内部类只能访问局部final修饰的变量**

内部类编译后会生成两个字节码文件，相对独立，属于同一级别

而方法执行结束后，内部类并不会被销毁（例如多线程）；所以当外部方法执行结束后，局部变量被销毁，所以内部类实际访问的外部变量是复制了一份出来，为了保证内部类和外部方法的变量保持一致，因此只能使用final修饰，防止内部类修改而外部方法不能感知

# String、StringBuffer、StringBuilder

String是final修饰的，不可变，每次操作都会产生新的String对象

StringBuffer和StringBuilder都是在原对象上操作

StringBuffer所有方法都用synchronized修饰，是线程安全的

性能：StringBuilder>StringBuffer>String

应用场景：对于经常修改的字符串内容采用后面两个

优先使用StringBuilder，多线程共享变量时使用StringBuffer

# 重载和重写区别

**重载**：发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，返回值和访问修饰符可以不同，发生在编译时

**重写**：发生在父子类中，方法名，参数列表必须相同；返回值范围小于等于父类，抛出异常小于等于父类，访问修饰符大于等于父类；如果父类修饰符为private则子类就不能重写该方法

# 接口和抽象类区别

- 抽象类可以存在普通成员函数，而接口只能存在public abstract方法
- 抽象类成员变量可以是各种类型，而接口的成员变量只能是public static final类型
- 抽象类只能继承一个，接口可以实现多个

接口设计是为了对类的行为进行约束，约束了行为的有无，但不限制具体实现

抽象类的设计是为了代码复用，是由子类派生出来的，不能实例化，因为存在抽象方法

接口表达的是 like a，即什么像什么（鸟像飞机一样可以飞）

抽象类表达的是 is a，即什么是什么（麻雀是鸟）

抽象类的功能远大于接口，但定义的代价也较高；接口设计比抽象类简单许多

# List和Set区别

- List：有序，按对象进入顺序保存对象，可重复，能允许多个Null元素对象，可以使用Iterator取出所有元素，再逐一遍历，还可以使用get(int index)获取指定下标元素
- Set：无序，不可重复，最多允许一个Null元素对象，取元素时只能通过Iterator取出所有元素，再逐一遍历

# hashCode与equals

- hashCode介绍

  hashCode()的作用是获取哈希码（散列码），实际上返回的是一个int整数。这个哈希码作用是确定该对象在哈希表中索引的位置。hashCode()定义在Object类中，因此java所有类都包含hashCode()函数。哈希表存储的是键值对，它的特点：嫩更具“键“快速检索出对应的值。其中应用到了哈希码（可以快速找到所需要的对象）

- hashCode存在意义（以HashSet为例）

  对象加入HashSet时，先计算哈希值来判断对象加入位置，看该位置是否有值；没有则直接加入，有值则在进行equals比较看是否为同一对象，是则操作不成功，不是同一对象则重新散列到其他位置。这样大大减少了equals的次数，提升了执行效率



- 如果两个对象相等，则hashCode返回一定相同，equals一定返回true
- 两对象hashCode返回相同，不一定相等
- equals方法覆盖过，hashCode方法一定也要覆盖
- hashCode()默认是对堆上的对象产生独特的值，不重写，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

# 面试知识点

## 正则表达式的规则

1. 任意一个字符表示匹配任意对应的字符，如a匹配a，7匹配7，-匹配-。

2. []代表匹配中括号中其中任一个字符，如[abc]匹配a或b或c。

3. -在中括号里面和外面代表含义不同，如在外时，就匹配-，如果在中括号内[a-b]表示匹配26个小写字母中的任一个；[a-zA-Z]匹配大小写共52个字母中任一个；[0-9]匹配十个数字中任一个。

4. ^在中括号里面和外面含义不同，如在外时，就表示开头，如^7[0-9]表示匹配开头是7的，且第二位是任一数字的字符串；如果在中括号里面，表示除了这个字符之外的任意字符(包括数字，特殊字符)，如[^abc]表示匹配出去abc之外的其他任一字符。

5. .表示匹配任意的字符。

6. \d表示数字。

7. \D表示非数字。

8. \s表示由空字符组成，[ \t\n\r\x\f]。

9. \S表示由非空字符组成，[^\s]。

10. \w表示字母、数字、下划线，[a-zA-Z0-9_]。

11. \W表示不是由字母、数字、下划线组成。

12. ?: 表示出现0次或1次。

13. +表示出现1次或多次。

14. *表示出现0次、1次或多次。

15. {n}表示出现n次。

16. {n,m}表示出现n~m次。

17. {n,}表示出现n次或n次以上。

18. XY表示X后面跟着Y，这里X和Y分别是正则表达式的一部分。

19. X|Y表示X或Y，比如"food|f"匹配的是foo（d或f），而"(food)|f"匹配的是food或f。

20. (X)子表达式，将X看做是一个整体

## 接口和抽象类

抽象类：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。

抽象类的特点：

1. 抽象类不能被实例化只能被继承
2. 包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法
3. 抽象类中的抽象方法的修饰符只能为public或者protected，默认为public
4. 一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类
5. 抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。

*接口*：Java中接口使用interface关键字修饰，特点为:

1. 接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）
2. 接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题
3. 一个类可以实现多个接口
4. JDK1.8中对接口增加了新的特性：
   1.  默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法
   2. 静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）

​    注意：**jdk1.9是允许接口中出现private修饰的默认方法和静态方法**。

## JVM内存相关

-Xms -Xmx分别设置堆的最小值和最大值，如果要设置成堆的大小可变，那么可以将最大值和最小值设置成不一样，如果要将堆大小固定，那么只需将最大值和最小值设置成一样的就行。

jvm中分为堆和方法区

**堆**又进一步分为**新生代和老年代**

**方法区为永久代**

堆中区分的新生代和老年代是为了垃圾回收，新生代中的对象存活期一般不长，而老年代中的对象存活期较长，所以当垃圾回收器回收内存时，新生代中垃圾回收效果较好，会回收大量的内存，而老年代中回收效果较差，内存回收不会太多。

基于以上特性，**新生代中一般采用复制算法**，因为存活下来的对象是少数，所需要复制的对象少，而老年代对象存活多，不适合采用复制算法，一般是**标记整理和标记清除算法**。

因为复制算法需要留出一块单独的内存空间来以备垃圾回收时复制对象使用，所以将**新生代分为eden区和两个survivor区**，每次使用eden和一个survivor区，另一个survivor作为备用的对象复制内存区。

综上：

-Xmn设置了新生代的大小为5120m，而-XXSurvivorRatio=3，所有将新生代共分成5分，eden占三份，survivor占两份，每份1/5（为什么是五份）

## 字符数组与字符串

```java
char[] a={'a','b','c'};
String b="abc";
System.out.println(b.equals(a)); //返回false

//String的equals方法
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    //判断是否可以向下转型为String，不能直接返回false
    if (anObject instanceof String) {
        String aString = (String)anObject;
        if (coder() == aString.coder()) {
            return isLatin1() ? StringLatin1.equals(value, aString.value)
                : StringUTF16.equals(value, aString.value);
        }
    }
    return false;
}
```

## 虚拟机类加载器结构

Java开始使用如下三种类型的类加载器

- 启动类加载器（bootstrap）：启动类加载器是用本地代码实现的类加载器，它负责将JAVA_HOME/lib下面的核心类库或-Xbootclasspath选项指定的jar包等虚拟机识别的类库加载到内存中
- 扩展类加载器（extension）：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将JAVA_HOME /lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中
- 系统类加载器（system）：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将用户类路径(java -classpath或-Djava.class.path变量所指的目录，即当前类所在路径及其引用的第三方类库的路径

双亲委派机制

- JVM在加载类时默认采用的是双亲委派机制
- 

## 数据类型

| 默认值  | 存储需求（字节） | 取值范围 | 示例         |                    |
| ------- | ---------------- | -------- | ------------ | ------------------ |
| byte    | 0                | 1        | -2^7—2^7-1   | byte b=10;         |
| char    | ‘ \u0000′        | 2        | 0—2^16-1     | char c=’c’ ;       |
| short   | 0                | 2        | -2^15—2^15-1 | short s=10;        |
| int     | 0                | 4        | -2^31—2^31-1 | int i=10;          |
| long    | 0                | 8        | -2^63—2^63-1 | long o=10L;        |
| float   | 0.0f             | 4        | -2^31—2^31-1 | float f=10.0F      |
| double  | 0.0d             | 8        | -2^63—2^63-1 | double d=10.0;     |
| boolean | false            | 1        | true\false   | boolean flag=true; |

## 进程线程

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。
2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
3. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
4. 处理机分给线程，即真正在处理机上运行的是线程。
5. 线程是指进程内的一个执行单元，也是进程内的可调度实体。

## servlet生命周期

Servlet的生命周期一般可以用三个方法来表示：

1. init()：仅执行一次，负责在装载Servlet时初始化Servlet对象
2. service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。
3. destory()：在停止并且卸载Servlet时执行，负责释放资源

初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法



