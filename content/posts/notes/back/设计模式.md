---
title: "设计模式"
date: 2023-03-04
lastmod: 2023-03-04
draft: false
tags: ['javase']
categories: ["笔记"]
author: "lei"
---

# 单例设计模式

> JDK 中的单例实例：Runtime 类

## 懒汉模式

> 注：java中不建议使用懒汉模式

懒汉模式：延迟加载，只有在真正使用的时候才开始实例化

1. 线程安全问题
2. double check 加锁优化
3. 编辑器（JIT），CPU 有可能对指令进行重排序，导致使用到尚未初始化的实例，可通过加 volatile 关键字修饰，对于 volatile 修饰的字段，可以防止指令重排

```java
class LazySingleton {
    // volatile 可以防止指令重排，获取到 null 对象
    // 在线程1实例化对象的过程中，刚好在将instance指向内存和未初始化之间
    // 线程2判断 instance 不为null（实际此时instance可能尚未初始化）
    private volatile static LazySingleton instance;

    private LazySingleton() {}

    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    // 1. 分配内存空间
                    // 2. instance 指向内存地址
                    // 3. 初始化内存空间内容
                    // 2 3 步骤可能会因为 JIT 或 CPU 指令重排
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```

## 饿汉模式

饿汉模式，类加载的初始化阶段就完成了实例的初始化。实际上是借助 jvm 类加载机制，保证实例唯一性

类加载过程：

1. 加载二进制数据到内存中，生成对应的 Class 数据结构
2. 连接：a.验证，b.准备（给类的静态成员变量赋默认值），c.解析
3. 初始化：给类的静态变量赋初值

只有在真正使用对应的类时，才会触发初始化

```java
class HungrySingle{
    private static final HungrySingle instance=new HungrySingle();

    private HungrySingle(){}

    public static HungrySingle getInstance(){
        return instance;
    }
}
```

## 枚举类

Java 保证枚举类的每个枚举都是单例，可以使用枚举实现单例

```java
public class EnumSingletonDemo {
    public static void main(String[] args) throws Exception {
        // 枚举构造参数 （String，int） 参考 Enum 类
        Constructor<EnumSingleton> constructor = EnumSingleton.class.getDeclaredConstructor(String.class,int.class);
        constructor.setAccessible(true);
        EnumSingleton instance = constructor.newInstance("INSTANCE", 1);
}

enum EnumSingle{
    INSTANCE;
    public static EnumSingle getInstance() {
        return INSTANCE;
    }
}
```

> 枚举通过反射也不能实例化，参考 Enum 类和 Constructor.newInstance，如果是枚举会抛错



